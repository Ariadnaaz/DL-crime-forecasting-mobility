# -*- coding: utf-8 -*-
"""2.Make_sociodem_grids.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EnT0TLcm4jaVnNtpwXQv9BqztpQj5Wuu
"""

!pip install pandarallel
!pip install pygris

import geopandas as gpd
#import tqdm
import pandas as pd
import os #, glob
import folium
import numpy as np
import fiona
import json
from shapely.geometry import Point, LineString
import shapely.geometry
import pygris
import seaborn as sns
import matplotlib.pyplot as plt

from pandarallel import pandarallel
from pathlib import Path
import os
pandarallel.initialize(nb_workers=min(os.cpu_count(), 12),progress_bar=True)

import warnings
warnings.filterwarnings('ignore')

from google.colab import drive
drive.mount('/content/drive')

"""### Useful functions"""

def extract_multipolygon_city(file_path,city_name):
    '''
    Extracts the entry in the geojson file corresponding to the city selected and outputs the
    corresponding geodataframe with the multipolygon.

        Parameters:
            file_path (str): File path to the geojson
            city_name (str): Name of the city we selected

        Returns:
            feature (geopandas): The geopandas dataframe for that city
    '''
    d = pd.read_json(file_path)
    for feature in d["features"]:
        if feature[0]['properties']['city'] == city_name:
            return gpd.GeoDataFrame.from_features(feature)


def find_variable_description(var_code):
    with open("drive/MyDrive/PhD_thesis/Sociodemographic_data/sociodem_vars_map.txt", "r") as fp:
        # Load the dictionary from the file
        d = json.load(fp)
    # find the dictionary key that contains that var
    desc = [value for key, value in d.items() if var_code in key][0]
    return desc

"""### 1. Make final grid files for all years together"""

def get_data_per_cell(row,df):
  """
    Aggregates sociodemographic data for a spatial grid cell by averaging data
    from all intersecting block groups.

    Parameters
    ----------
    row : pandas.Series
        A row from the grid-to-block-group mapping dataframe (`df_map`).
        Must contain a 'block_groups' column listing GEOIDs as a stringified list.
    df : pandas.DataFrame
        The sociodemographic data indexed by GEOID (block group ID).

    Returns
    -------
    pandas.Series
        A Series containing the average sociodemographic features for the cell.
        Returns a Series of NaNs if no valid block group data is found.
  """
  list_bg = row['block_groups']
  if isinstance(list_bg, str): # we check that list is not empty
    data_list = []
    for geoid in eval(list_bg):
      # check if geoid is in data file
      if geoid in df.index:
        data_list.append(df.loc[geoid])
    if data_list: # check if we did't make any dataframes bc of missing geoids in data
      df_bgs = pd.concat(data_list, axis = 1)
      df_avg = df_bgs.T.mean()
    else:
      # CAREFUL NUM VARIABLES IS HARDCODED
      df_avg = pd.DataFrame(np.full((1,26),np.nan),columns=df.columns.values.tolist()).squeeze()
  else:
    df_avg = pd.DataFrame(np.full((1,26),np.nan),columns=df.columns.values.tolist()).squeeze()
  return df_avg

def make_final_grid_sociodem(city_name,city_folder,input_folder,map_folder,output_folder):
  """
    Creates a cell-level sociodemographic dataset for a given city by aggregating
    block group-level data over a spatial grid across multiple years.

    For each grid cell, the function:
    - Identifies intersecting block groups
    - Averages their sociodemographic values
    - Removes cells outside the city boundary
    - Merges data across 2019, 2020, and 2021
    - Saves the result to a CSV file

    Parameters
    ----------
    city_name : str
        Name of the city (used to filter the multipolygon boundaries).
    city_folder : str
        Name of the folder containing city-specific data.
    input_folder : str
        Folder containing input sociodemographic CSV files per year.
    map_folder : str
        Folder containing the grid-to-block-group mapping CSV file.
    output_folder : str
        Folder to save the final output CSV file.

    Returns
    -------
    None
        The function saves the final cell-level sociodemographic data to disk.
  """
  # we assume all years use same geoid...
  df_map = pd.read_csv(f'drive/MyDrive/PhD_thesis/Sociodemographic_data/{map_folder}/{city_folder}_cell_to_geoids_map.csv',index_col=0)
  df_map['polygon'] = gpd.GeoSeries.from_wkt(df_map['polygon'])

  df_all_list = []
  for year in [2019,2020,2021]:
    print(f"Doing year {year}...")
    df_data = pd.read_csv(f'drive/MyDrive/PhD_thesis/Sociodemographic_data/{input_folder}/{city_folder}_sociodem_{year}.csv')
    df_data['GEOID'] = df_data['GEOID'].str.replace('15000US', '')
    df_data.set_index('GEOID',drop=True,inplace=True)

    print("Finding the GEOID of all block groups intersecting with each cell...")
    temp = df_map.parallel_apply(get_data_per_cell,df=df_data,axis=1)
    df_year = df_map.merge(temp,left_index=True, right_index= True)

    # set to NaN the rows where polygon doesn't intersect with city polygon
    gdf = extract_multipolygon_city(file_path='drive/MyDrive/PhD_thesis/Crime_data/city_multipolygons.geojson',city_name=city_name)
    for i,row in df_year.iterrows():
      if not row['polygon'].intersects(gdf.geometry[0]):
        df_year.loc[i] = np.nan

    # remove polygon and block_group
    df_year.drop(columns=['polygon','block_groups'],inplace=True)
    df_year.columns = list(map(lambda x: str(x) + f"_{str(year)}", df_year.columns.tolist()))
    df_all_list.append(df_year)

  # concat the 4 years
  print("Concatenating and saving final dataframe...")
  df_all = pd.concat(df_all_list,axis=1)

  # make final output folder if it doesn't exist
  #Path(f"drive/MyDrive/Sociodemographic_data/{output_folder}").mkdir(exist_ok=True)

  df_all.T.to_csv(f"drive/MyDrive/PhD_thesis/Sociodemographic_data/{output_folder}/{city_folder}_sociodem_all_final_grid.csv")
  print("Shape final dataframe: ", df_all.T.shape)
  print("File saved!")

make_final_grid_sociodem(city_name='Baltimore',
                         city_folder='Baltimore',
                         input_folder='Sociodem_data_corrected',
                         map_folder='Sociodem_data_corrected/Grid_cells_0.2gu',
                         output_folder='Sociodem_data_corrected/Grid_cells_0.2gu/Final_all')

make_final_grid_sociodem(city_name='Chicago',
                         city_folder='Chicago',
                         input_folder='Sociodem_data_corrected',
                         map_folder='Sociodem_data_corrected/Grid_cells_0.2gu',
                         output_folder='Sociodem_data_corrected/Grid_cells_0.2gu/Final_all')

make_final_grid_sociodem(city_name='Los Angeles',
                         city_folder='Los_Angeles',
                         input_folder='Sociodem_data_corrected',
                         map_folder='Sociodem_data_corrected/Grid_cells_0.2gu',
                         output_folder='Sociodem_data_corrected/Grid_cells_0.2gu/Final_all')

make_final_grid_sociodem(city_name='Philadelphia',
                         city_folder='Philadelphia',
                         input_folder='Sociodem_data_corrected',
                         map_folder='Sociodem_data_corrected/Grid_cells_0.2gu',
                         output_folder='Sociodem_data_corrected/Grid_cells_0.2gu/Final_all')

"""### Visualize final matrices sociodem"""

def plot_final_sociodem_matrix(city_name,city_folder,var_code,year,input_folder,grid_size=50):

  df_sociodem = pd.read_csv(f"drive/MyDrive/PhD_thesis/Sociodemographic_data/{input_folder}/{city_folder}_sociodem_all_final_grid.csv",index_col=0)
  print(df_sociodem.shape)

  # get the variable and put into right shape so that cell numbers correspond with their physical location
  df_var_year = df_sociodem.loc[var_code+'_'+str(year)]
  df_var_year_list = df_var_year.values.tolist()
  df_var_year_list.reverse()
  sociodem_matrix = np.array(df_var_year_list).reshape(grid_size, grid_size).T

  # get variable description
  desc = find_variable_description(var_code=var_code)

  # define heatmap
  ax = sns.heatmap(sociodem_matrix, linewidth=0.6,cmap="rocket_r")
  plt.title(f"{desc} in {city_name} {year}")

  # remove ticks indicating grid cell num
  plt.xticks([])
  plt.yticks([])

  # add black box around
  ax.axhline(y=0, color='k',linewidth=2)
  ax.axhline(y=sociodem_matrix.shape[1], color='k',linewidth=2)
  ax.axvline(x=0, color='k',linewidth=2)
  ax.axvline(x=sociodem_matrix.shape[0], color='k',linewidth=2)

  plt.show()

plot_final_sociodem_matrix(city_name='Philadelphia',city_folder='Philadelphia',var_code='B23025e5',year=2019,input_folder='Sociodem_data_corrected/Grid_cells_0.2gu/Final_all',grid_size=64)

"""## Visualize block groups and grid cells"""

import folium
import geopandas as gpd
import pandas as pd
import pygris

from google.colab import drive
drive.mount('/content/drive')

def plot_city_border_blockgroups_and_gridcells(selected_city, state, county, city_folder, map_folder):
    """
    Plots the city boundary, Census block groups (via pygris), and grid cells
    (from your predefined mapping file) using Folium.

    Parameters
    ----------
    selected_city : str
        Name of the city (e.g. 'Los Angeles')
    state : str
        State FIPS code or abbreviation (e.g. 'CA' or '06')
    county : str
        County name (e.g. 'Los Angeles')
    city_folder : str
        Folder containing city-specific files
    map_folder : str
        Folder containing the cell-to-block-group mapping CSV
    """

    # Load city polygon
    gdf = extract_multipolygon_city(file_path='drive/MyDrive/PhD_thesis/Crime_data/city_multipolygons.geojson', city_name=selected_city)
    bbox = gdf.total_bounds
    min_lon, min_lat, max_lon, max_lat = (bbox[2], bbox[1], bbox[0], bbox[3])

    # Initialize folium map
    m = folium.Map(location=((min_lat + max_lat) / 2, (min_lon + max_lon) / 2), zoom_start=11)

    # Load block groups using pygris
    block_groups = pygris.block_groups(state=state, county=county)
    print("Shape block groups df: ", block_groups.shape)

    # Plot block groups
    for elem in block_groups.geometry:
        geo_j = folium.GeoJson(data=elem, style_function=lambda x: {'color': '#999999', 'weight': 0.5, 'fillOpacity': 0.1})
        geo_j.add_to(m)

    # Plot city boundary
    cgeo = (
        gdf.set_crs("epsg:4326")
        .sample(1)
        .pipe(lambda d: d.to_crs(d.estimate_utm_crs()))["geometry"]
        .to_crs("epsg:4326")
        .__geo_interface__
    )
    city_style = {'color': '#000000', 'weight': 2}
    folium.GeoJson(data=cgeo, style_function=lambda x: city_style).add_to(m)

    # Load grid cell polygons from your mapping file
    df_map = pd.read_csv(f'drive/MyDrive/PhD_thesis/Sociodemographic_data/{map_folder}/{city_folder}_cell_to_geoids_map.csv', index_col=0)
    df_map['geometry'] = gpd.GeoSeries.from_wkt(df_map['polygon'])
    gdf_cells = gpd.GeoDataFrame(df_map, geometry='geometry', crs="EPSG:4326")

    # Clip grid cells to city boundary (optional, for cleaner view)
    gdf_cells = gpd.clip(gdf_cells, gdf)

    # Plot grid cells
    for geom in gdf_cells.geometry:
        folium.GeoJson(data=geom.__geo_interface__, style_function=lambda x: {'color': 'red', 'weight': 1, 'fillOpacity': 0}).add_to(m)

    display(m)

plot_city_border_blockgroups_and_gridcells(selected_city='Baltimore',
                                           state='MD',
                                           county='510',
                                           city_folder='Baltimore',
                                           map_folder='Sociodem_data_corrected/Grid_cells_0.2gu')

import pygris # GETTINGN HTTP ERROR 403, TRY WITH DIFFERENT WIFI NETWORK...

ny_roads = pygris.roads(state = "NY", county = "New York")

ny_roads.plot()
